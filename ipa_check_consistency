#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Tool to check consistency across FreeIPA servers

Author: Peter Pakos <peter.pakos@wandisco.com>

Copyright (C) 2017 WANdisco

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import print_function
import os
import sys
import argparse
import fcntl
from logger import get_logger
from FreeIPAServer import FreeIPAServer
from prettytable import PrettyTable
import dns.resolver


class Main(object):
    VERSION = '2.1.0'

    def __init__(self):
        if not self._lock_file():
            print('The script is already running, exiting...', file=sys.stderr)
            exit(1)

        self._args = self._parse_args()
        self._log = get_logger(debug=self._args.debug, quiet=self._args.quiet, verbose=self._args.verbose)
        self._log.debug(self._args)
        self._log.debug('Initialising...')

        domain = None
        servers = []
        binddn = 'cn=Directory Manager'
        bindpw = None

        # Reading configuration from file
        if not os.path.isfile(os.path.dirname(os.path.realpath(__file__)) + '/config.py'):
            self._log.error('Config file not found')
        else:
            self._log.debug('Reading config file')
            from config import Config

            if hasattr(Config, 'DOMAIN'):
                domain = Config.DOMAIN
                self._log.debug('DOMAIN = %s' % domain)
            else:
                self._log.debug('DOMAIN not set in config file')

            if hasattr(Config, 'SERVERS'):
                servers = Config.SERVERS
                self._log.debug('SERVERS = %s' % servers)
            else:
                self._log.debug('SERVERS not set in config file')

            if hasattr(Config, 'BINDDN'):
                binddn = Config.BINDDN
                self._log.debug('BINDDN = %s' % binddn)
            else:
                self._log.debug('BINDDN not set in config file')

            if hasattr(Config, 'BINDPW'):
                bindpw = Config.BINDPW
                self._log.debug('BINDPW = ********')
            else:
                self._log.debug('BINDPW not set in config file')

        if self._args.domain:
            self._log.debug('Domain set by argument')
            domain = self._args.domain

        if not domain:
            self._log.critical('IPA domain not set')
            exit(1)
        else:
            self._log.debug('IPA domain: %s' % domain)

        if self._args.host:
            self._log.debug('Server list set by argument')
            servers = self._args.host

        for i, server in enumerate(servers):
            if '.' not in server:
                servers[i] = server + '.' + domain
            if not server or ' ' in server:
                self._log.critical('Incorrect server name: %s' % server)
                exit(1)

        if not servers:
            self._log.debug('Searching for IPA servers in DNS')
            record = '_ldap._tcp.%s' % domain
            answers = []

            try:
                answers = dns.resolver.query(record, 'SRV')
            except dns.resolver.NXDOMAIN:
                self._log.critical('IPA servers not set, also failed to find any in DNS')
                exit(1)

            for answer in answers:
                servers.append(str(answer).split(' ')[3].rstrip('.'))

        self._log.debug('IPA servers: %s' % ', '.join(servers))

        if self._args.binddn:
            self._log.debug('Bind DN set by argument')
            binddn = self._args.binddn

        if not binddn:
            self._log.critical('Bind DN not set')
            exit(1)

        if self._args.bindpw:
            self._log.debug('Bind password set by argument')
            bindpw = self._args.bindpw

        if not bindpw:
            self._log.critical('Bind password not set')
            exit(1)

        self._servers = {}
        for fqdn in servers:
            self._servers[fqdn] = FreeIPAServer(fqdn, binddn, bindpw)

        self._checks = {
            'users': 'Active Users',
            'ustage': 'Stage Users',
            'upres': 'Preserved Users',
            'ugroups': 'User Groups',
            'hosts': 'Hosts',
            'hgroups': 'Host Groups',
            'hbac': 'HBAC Rules',
            'sudo': 'SUDO Rules',
            'zones': 'DNS Zones',
            'certs': 'Certificates',
            'ldap': 'LDAP Conflicts',
            'ghosts': 'Ghost Replicas',
            'bind': 'Anonymous BIND',
            'msdcs': 'Microsoft ADTrust',
            'replica': 'Replication Status'
        }

    @staticmethod
    def _lock_file(lock_file='.lock'):
        file_descriptor = os.open(lock_file, os.O_CREAT | os.O_TRUNC | os.O_WRONLY)
        try:
            fcntl.lockf(file_descriptor, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            return False

        return True

    def _parse_args(self):
        parser = argparse.ArgumentParser(description='Tool to check consistency across FreeIPA servers', add_help=False)
        parser.add_argument('-H', '--host', nargs='*', dest='host', help='list of IPA servers')
        parser.add_argument('-d', '--domain', nargs='?', dest='domain', help='IPA domain')
        parser.add_argument('-D', '--binddn', nargs='?', dest='binddn', help='Bind DN (default: cn=Directory Manager)')
        parser.add_argument('-W', '--bindpw', nargs='?', dest='bindpw', help='Bind password')
        parser.add_argument('--version', action='version',
                            version='%s %s' % (os.path.basename(sys.argv[0]), self.VERSION))
        parser.add_argument('--help', action='help', help='show this help message and exit')
        parser.add_argument('--debug', action='store_true', dest='debug', help='debugging mode')
        parser.add_argument('--verbose', action='store_true', dest='verbose', help='verbose mode')
        parser.add_argument('--quiet', action='store_true', dest='quiet', help='do not log to console')
        parser.add_argument('--no-header', action='store_true', dest='disable_header', help='disable table header')
        parser.add_argument('--no-border', action='store_true', dest='disable_border', help='disable table border')
        parser.add_argument('-n', nargs='?', dest='nagios_check', help='Nagios plugin mode',
                            default='no', choices=['', 'all', 'users', 'ustage', 'upres', 'ugroups', 'hosts', 'hgroups',
                                                   'hbac', 'sudo', 'zones', 'certs', 'ldap', 'ghosts', 'bind', 'msdcs',
                                                   'replica'])
        parser.add_argument('-w', '--warning', type=int, dest='warning',
                            default=1, help='number of failed checks before warning (default: %(default)s)')
        parser.add_argument('-c', '--critical', type=int, dest='critical',
                            default=2, help='number of failed checks before critical (default: %(default)s)')

        args = parser.parse_args()

        if args.nagios_check == 'no':
            args.nagios_check = None
        elif not args.nagios_check:
            args.nagios_check = 'all'

        return args

    def run(self):
        self._log.debug('Starting...')
        if self._args.nagios_check:
            self._log.debug('Nagios plugin mode')
            self._nagios_plugin(self._args.nagios_check)
        else:
            self._log.debug('CLI mode')
            self._print_table()
        self._log.debug('Finishing...')

    def _print_table(self):
        table = PrettyTable(
            ['FreeIPA servers:'] + [getattr(server, 'hostname_short') for server in self._servers.values()] + ['STATE'],
            header=not self._args.disable_header,
            border=not self._args.disable_border
        )
        table.align = 'l'

        for check in self._checks:
            state = 'OK' if self._is_consistent(check, [getattr(server, check) for server in self._servers.values()])\
                else 'FAIL'
            table.add_row(
                [self._checks[check]] +
                [getattr(server, check) for server in self._servers.values()] +
                [state]
            )

        self._log.info(table)

    def _is_consistent(self, check, check_results):
        if check == 'ldap' and 'YES' in check_results:
            return False
        elif check == 'ghosts' and 'YES' in check_results:
            return False
        elif check == 'replica':
            healths = [getattr(server, 'healthy_agreements') for server in self._servers.values()]
            if healths.count(healths[0]) == len(healths) and healths[0]:
                return True
            else:
                return False
        if check_results.count(check_results[0]) == len(check_results):
            return True
        else:
            return False

    def _nagios_plugin(self, check):
        self._log.debug('Running check: %s' % check)
        if check == 'all':
            checks_no = len(self._checks)
            oks = 0
            for check in self._checks:
                if self._is_consistent(check, [getattr(server, check) for server in self._servers.values()]):
                    oks += 1
            fails = checks_no - oks
            if 0 <= fails < self._args.warning:
                msg = 'OK'
                code = 0
            elif self._args.warning <= fails < self._args.critical:
                msg = 'WARNING'
                code = 1
            elif fails >= self._args.critical:
                msg = 'CRITICAL'
                code = 2
            else:
                msg = 'UNKNOWN'
                code = 3
            self._log.info('%s - %s/%s checks passed' % (msg, oks, checks_no))
            exit(code)
        else:
            if self._is_consistent(check, [getattr(server, check) for server in self._servers.values()]):
                msg = 'OK'
                code = 0
            else:
                msg = 'CRITICAL'
                code = 2
            self._log.info('%s - %s' % (msg, self._checks[check]))
            exit(code)


if __name__ == '__main__':
    try:
        Main().run()
    except KeyboardInterrupt:
        print('\nTerminating...')
        exit(130)
