#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tool to check consistency across FreeIPA servers

Author: Peter Pakos <peter.pakos@wandisco.com>

Copyright (C) 2017 WANdisco

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import print_function
import os
import sys
import argparse
import fcntl
from config import Config
from logger import get_logger
from FreeIPAServer import FreeIPAServer
from prettytable import PrettyTable


class Main(object):
    VERSION = '2.0.0'

    def __init__(self):
        if not self._lock_file():
            print('The script is already running, exiting...', file=sys.stderr)
            exit(1)

        self._args = self._parse_args()
        self._log = get_logger(debug=self._args.debug, quiet=self._args.quiet, verbose=self._args.verbose)
        self._log.debug(self._args)
        self._log.debug('Initialising...')
        self._checks = {
            'users': 'Active Users',
            'ustage': 'Stage Users',
            'upres': 'Preserved Users',
            'ugroups': 'User Groups',
            'hosts': 'Hosts',
            'hgroups': 'Host Groups',
            'hbac': 'HBAC Rules',
            'sudo': 'SUDO Rules',
            'zones': 'DNS Zones',
            'certs': 'Certificates',
            'ldap': 'LDAP Conflicts',
            'ghosts': 'Ghost Replicas',
            'bind': 'Anonymous BIND',
            'msdcs': 'Microsoft ADTrust',
            'replica': 'Replication Status'
        }

        self._servers = {}

        for server in Config.SERVERS:
            self._servers[server] = FreeIPAServer(server, Config.DOMAIN, Config.BINDDN, Config.BINDPW)

    @staticmethod
    def _lock_file(lock_file='.lock'):
        file_descriptor = os.open(lock_file, os.O_CREAT | os.O_TRUNC | os.O_WRONLY)
        try:
            fcntl.lockf(file_descriptor, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            return False

        return True

    def _parse_args(self):
        parser = argparse.ArgumentParser(description='Tool to check consistency across FreeIPA servers', add_help=False)
        parser.add_argument('--version', action='version',
                            version='%s %s' % (os.path.basename(sys.argv[0]), self.VERSION))
        parser.add_argument('--help', action='help', help='show this help message and exit')
        parser.add_argument('--debug', action='store_true', dest='debug', help='debugging mode')
        parser.add_argument('--verbose', action='store_true', dest='verbose', help='verbose logging mode')
        parser.add_argument('--quiet', action='store_true', dest='quiet', help="don't log to console")
        parser.add_argument('-H', '--disable-header', action='store_true', dest='disable_header',
                            help='disable table header')
        parser.add_argument('-B', '--disable-border', action='store_true', dest='disable_border',
                            help='disable table border')
        parser.add_argument('-n', nargs='?', dest='nagios_check', help='Nagios plugin mode',
                            default='no', choices=['', 'all', 'users', 'ustage', 'upres', 'ugroups', 'hosts', 'hgroups',
                                                   'hbac', 'sudo', 'zones', 'certs', 'ldap', 'ghosts', 'bind', 'msdcs',
                                                   'replica'])
        parser.add_argument('-w', '--warning', type=int, dest='warning',
                            default=1, help='number of failed checks before warning (default: %(default)s)')
        parser.add_argument('-c', '--critical', type=int, dest='critical',
                            default=2, help='number of failed checks before critical (default: %(default)s)')

        args = parser.parse_args()

        if args.nagios_check == 'no':
            args.nagios_check = None
        elif not args.nagios_check:
            args.nagios_check = 'all'

        return args

    def run(self):
        self._log.debug('Starting...')
        if self._args.nagios_check:
            self._log.debug('Nagios plugin mode')
            self._nagios_plugin(self._args.nagios_check)
        else:
            self._log.debug('CLI mode')
            self._print_table()
        self._log.debug('Finishing...')

    def _print_table(self):
        table = PrettyTable(
            ['FreeIPA servers:'] + [getattr(server, 'hostname_short') for server in self._servers.values()] + ['STATE'],
            header=not self._args.disable_header,
            border=not self._args.disable_border
        )
        table.align = 'l'

        for check in self._checks:
            state = 'OK' if self._is_consistent(check, [getattr(server, check) for server in self._servers.values()])\
                else 'FAIL'
            table.add_row(
                [self._checks[check]] +
                [getattr(server, check) for server in self._servers.values()] +
                [state]
            )

        self._log.info(table)

    def _is_consistent(self, check, check_results):
        if check == 'ldap' and 'YES' in check_results:
            return False
        elif check == 'ghosts' and 'YES' in check_results:
            return False
        elif check == 'replica':
            healths = [getattr(server, 'healthy_agreements') for server in self._servers.values()]
            if healths.count(healths[0]) == len(healths) and healths[0]:
                return True
            else:
                return False
        if check_results.count(check_results[0]) == len(check_results):
            return True
        else:
            return False

    def _nagios_plugin(self, check):
        self._log.debug('Running check: %s' % check)
        if check == 'all':
            checks_no = len(self._checks)
            oks = 0
            for check in self._checks:
                if self._is_consistent(check, [getattr(server, check) for server in self._servers.values()]):
                    oks += 1
            fails = checks_no - oks
            if 0 <= fails < self._args.warning:
                msg = 'OK'
                code = 0
            elif self._args.warning <= fails < self._args.critical:
                msg = 'WARNING'
                code = 1
            elif fails >= self._args.critical:
                msg = 'CRITICAL'
                code = 2
            else:
                msg = 'UNKNOWN'
                code = 3
            self._log.info('%s - %s/%s checks passed' % (msg, oks, checks_no))
            exit(code)
        else:
            if self._is_consistent(check, [getattr(server, check) for server in self._servers.values()]):
                msg = 'OK'
                code = 0
            else:
                msg = 'CRITICAL'
                code = 2
            self._log.info('%s - %s' % (msg, self._checks[check]))
            exit(code)


if __name__ == '__main__':
    try:
        Main().run()
    except KeyboardInterrupt:
        print('\nTerminating...')
        exit(130)
